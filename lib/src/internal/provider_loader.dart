import 'dart:io';
import 'package:path/path.dart' as path;
import '../module.dart';
import '../module_provider.dart';
import '../build/provider_parser.dart';

/// Dynamic provider loader that loads providers without app imports
/// Uses module exports to access providers dynamically
class ProviderLoader {
  final String projectRoot;
  final String modulesPath;

  ProviderLoader({
    required this.projectRoot,
    required this.modulesPath,
  });

  /// Load and register all providers for a module
  /// Returns list of registered provider factories
  Future<Map<String, ProviderFactory>> loadProvidersForModule(
    Module module,
  ) async {
    final factories = <String, ProviderFactory>{};

    if (!module.enabled) {
      return factories;
    }

    for (final providerClass in module.providers) {
      try {
        final factory = await _createProviderFactory(module, providerClass);
        if (factory != null) {
          factories[providerClass] = factory;
        }
      } catch (e) {
        print(
          'Warning: Failed to load provider "$providerClass" from module "${module.name}": $e',
        );
      }
    }

    return factories;
  }

  /// Create a provider factory for a given provider class
  /// Uses code generation to create internal cache
  Future<ProviderFactory?> _createProviderFactory(
    Module module,
    String providerClass,
  ) async {
    try {
      final parsed = ProviderParser.parse(providerClass);
      final packageName = parsed['package']!;
      final importPath = parsed['import']!;
      final className = parsed['className']!;

      // Since Dart doesn't support runtime imports, we'll use code generation
      // to create an internal cache file that contains all provider factories
      // This cache will be generated at build time and loaded at runtime
      return _createFactoryFromCache(
        module,
        packageName,
        importPath,
        className,
        providerClass,
      );
    } catch (e) {
      print('Warning: Failed to parse provider class "$providerClass": $e');
      return null;
    }
  }

  /// Create factory from internal cache
  /// The cache is generated at build time with all provider factories
  ProviderFactory? _createFactoryFromCache(
    Module module,
    String packageName,
    String importPath,
    String className,
    String providerClass,
  ) {
    // Check if we have a cached factory
    // The cache will be generated by the build command
    // For now, return null - will be implemented with code generation
    // This allows the registry to work with manually registered factories
    // while we implement the full code generation system
    return null;
  }

  /// Alternative: Load providers using module export interface
  /// Modules export a standard registration function
  Future<Map<String, ProviderFactory>> loadProvidersFromModuleExports(
    List<Module> modules,
  ) async {
    final allFactories = <String, ProviderFactory>{};

    for (final module in modules) {
      if (!module.enabled) continue;

      try {
        // Try to load module export file
        final exportFile = File(
          path.join(module.modulePath, 'lib', 'module_export.dart'),
        );

        if (exportFile.existsSync()) {
          // Parse export file to get provider factories
          // This would require code generation or a standard export format
          final factories = await _parseModuleExport(module, exportFile);
          allFactories.addAll(factories);
        } else {
          // Fallback: use provider class names to create factories
          // This requires modules to follow a standard pattern
          for (final providerClass in module.providers) {
            final factory = _createFactoryFromClassName(module, providerClass);
            if (factory != null) {
              allFactories[providerClass] = factory;
            }
          }
        }
      } catch (e) {
        print(
          'Warning: Failed to load providers from module "${module.name}": $e',
        );
      }
    }

    return allFactories;
  }

  /// Parse module export file
  Future<Map<String, ProviderFactory>> _parseModuleExport(
    Module module,
    File exportFile,
  ) async {
    // This would parse a standard export file format
    // For now, return empty map - to be implemented with code generation
    return <String, ProviderFactory>{};
  }

  /// Create factory from class name (fallback)
  ProviderFactory? _createFactoryFromClassName(
    Module module,
    String providerClass,
  ) {
    // This is a placeholder - actual implementation would use
    // code generation or reflection
    return null;
  }
}

/// Provider factory type
typedef ProviderFactory = ModuleProvider? Function(Module module);
